{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dockit","text":"<p>Dead simple, yet powerful, authentication for any OCI registry.</p>"},{"location":"#overview","title":"Overview","text":"<p>Dockit is a robust authentication system for an OCI compatible registry.</p>"},{"location":"#admin-api","title":"Admin API","text":"<p>Dockit has an Admin API that is used to manage the permissions. Dockit supports users and groups and both can have permissions assigned to them.</p>"},{"location":"#authentication","title":"Authentication","text":"<p>Authentication to the Admin API is done via basic authentication using usernam/password. By default it will attempt to use docker credentials stored against the registry on your system, but the user has to have the admin flag set to true. If for some reason credentials cannot be obtained from the docker configuration, you can specify them on the command line.</p>"},{"location":"#registries","title":"Registries","text":""},{"location":"#docker-distribution","title":"Docker Distribution","text":"<p>Authentication with distribution is based on tokens and PKI, the x509 version of the public key has to be made available to the distribution instance upon start. Dockit comes with an init-container capability that will fetch all known keys and return them so they can be written to disk for the registry to use.</p> <p>Note: unfortunately the distribution registry only reads the cert bundle on start and requires a restart to include any new ones.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>It's fairly straight forward to configure the docker distribution registry to delegate authentication to Dockit.</p> <p>The easiest and recommended method is via environment variables.</p> <p>The following environment values should be set:</p> <ul> <li><code>REGISTRY_AUTH_TOKEN_SERVICE</code> this is the name of your service</li> <li><code>REGISTRY_AUTH_TOKEN_ISSUER</code> with value <code>dockit</code></li> <li><code>REGISTRY_AUTH_TOKEN_REALM</code> this should be the https URL of where dockit is listening (example: https://dockit.private.io/v2/token)</li> <li><code>REGISTRY_AUTH_TOKEN_ROOTCERTBUNDLE</code> should be a pem that has all valid signing certs, if using dockit init-conatiner use <code>/dockit/certs.pem</code></li> </ul>"},{"location":"#cli","title":"CLI","text":"<pre><code>NAME:\n   dockit - simple and effective oci registry authentication\n\nUSAGE:\n   dockit [global options] command [command options] [arguments...]\n\nVERSION:\n   0.1.0-dev-dirty\n\nAUTHOR:\n   Erik Kristensen &lt;erik@erikkristensen.com&gt;\n\nCOMMANDS:\n   api-server      dockit api server\n   version         print version\n   init-container  Provides init container capability to fetch and store PKI from Dockit before starting registry server\n   pki-generate    generates an ecdsa private key and certificate\n   rbac            provides the ability to perform various RBAC related actions\n   help, h         Shows a list of commands or help for one command\n\nGLOBAL OPTIONS:\n   --help, -h     show help (default: false)\n   --version, -v  print the version (default: false)\n</code></pre>"},{"location":"#development","title":"Development","text":"<p>Developing on Dockit is pretty straight forward you just need a golang development environment. Unless you are willing to take the time to setup trusted certificates, you'll need to modify the docker daemon configuration you are interacting with to add your test registry URI to the insecure registries list.</p> <p>The <code>docker-compose.yml</code> in the repository is setup to deploy the docker distribution registry version 2 and point it at the <code>./hack/pki</code> folder to load the cert bundle.</p> <ol> <li><code>go run main.go api-server</code> -- start the api-server</li> <li><code>go run main.go init-container ./hack/pki/server/pem</code> -- run the init-container</li> <li><code>docker-compose up -d</code> -- start the docker registry</li> </ol> <p>Develop as necessary.</p>"},{"location":"database/","title":"Database","text":"<p>Dockit uses GORM for it's database connections and uses Snowflake to generate all the primary keys. The primary database that has been developed against and tested is SQLite. However MySQL has been tested as well.</p> <p>Snowflake is an algorithm from Twitter about generating <code>int64</code> integers based on time, node id, and sequential bits that allow for thousands of writes per millisecond. For most users of dockit this once matter and because of that, the default setting is to use a random number per instance on start up and log that ID out in the logs for tracking.</p> <p>If you'd like to manually manage the <code>node-id</code> you can in your deployment, the only reason you would need to do this and would care to do this is if you are expecting, 5000+ writes per millisecond to the registry.</p> <p>Note: this registry is mostly read heavy, writes are only performed when doing permissions.</p>"},{"location":"init-container/","title":"Init Container Support","text":"<p>Dockit comes with an <code>init-container</code> subcommand that's designed to be used with Kuberentes init containers. It can even be used with the latest version of docker compose.</p> <p>The <code>init-container</code> subcommand is designed to make an http call against the dockit api server to retrieve all non-expired certificaes in it's database and write those to a file. The docker distribution registry can then read the file from disk on start and used to validate JWT tokens.</p>"},{"location":"init-container/#kubernetes","title":"Kubernetes","text":"<p>With kubernetes, you can use the standard <code>initContainers</code> syntax to run the subcommand prior to the docker distribution registry starting.</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: registry\nspec:\n  initContainers:\n  - name: dockit-certs\n    image: ghcr.io/ekristen/dockit:latest\n    command:\n      - init-container\n      - /dockit/pki/bundle.pem\n  containers:\n  - name: server\n    image: registry:2\n    env:\n      - name: REGISTRY_AUTH_TOKEN_ISSUER\n        value: dockit\n      - name: REGISTRY_AUTH_TOKEN_REALM\n        value: http://host.docker.internal:4315/v2/token\n      - name: REGISTRY_AUTH_TOKEN_ROOTCERTBUNDLE\n        value: /dockit/pki/bundle.pem\n      - name: REGISTRY_AUTH_TOKEN_SERVICE\n        value: registry\n</code></pre>"},{"location":"init-container/#docker-compose","title":"Docker Compose","text":"<p>With docker compose, you can use version 3 and the latest docker compose binary you can use the newer depends_on syntax to make containers conditionally wait on each other.</p> <pre><code>version: '3'\nservices:\n  chown:\n    image: ubuntu\n    command: chown -R 999:999 /dockit\n    volumes:\n      - \"pki:/dockit/pki\"\n\n  init:\n    image: ghcr.io/ekristen/dockit:v0.2.4\n    command:\n      - init-container\n      - /dockit/pki/bundle.pem\n    restart: \"no\"\n    environment:\n      DOCKIT_BASE_URL: http://host.docker.internal:4315/v2\n    volumes:\n      - \"pki:/dockit/pki\"\n    depends_on:\n      chown:\n        condition: service_completed_successfully\n\n  registry:\n    image: registry:2\n    environment:\n      REGISTRY_AUTH_TOKEN_ISSUER: dockit\n      REGISTRY_AUTH_TOKEN_REALM: http://host.docker.internal:4315/v2/token\n      REGISTRY_AUTH_TOKEN_ROOTCERTBUNDLE: /dockit/pki/bundle.pem\n      REGISTRY_AUTH_TOKEN_SERVICE: registry\n    volumes:\n      - \"pki:/dockit/pki\"\n    ports:\n      - 5000:5000\n    depends_on:\n      init:\n        condition: service_completed_successfully\n\nvolumes:\n  pki:\n</code></pre>"},{"location":"guides/cert-manager/","title":"Managing PKI with Cert Manager","text":"<p>If you are using cert manager and would like to manage PKI for Dockit using it, the good news is you can. Furthermore this works with any backend that the cert-manager support so long as you can mount the certificate and corresponding private key into the Dockit container.</p> <p>No matter how you request a certificate the result end's up in an secret that looks like the following.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: dockit-tls\ntype: kubernetes.io/tls\ndata:\n  ca.crt: &lt;PEM CA certificate&gt;\n  tls.key: &lt;PEM private key&gt;\n  tls.crt: &lt;PEM signed certificate chain&gt;\n  tls-combined.pem: &lt;PEM private key + \"\\n\" + PEM signed certificate chain&gt;\n  key.der: &lt;DER binary format of private key&gt;\n</code></pre> <p>For the dockit container, you need to pass the appropriate volume information to the deployment.</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: dockit\nspec:\n  containers:\n    - name: api-server\n      image: ghcr.io/ekristen/dockit:latest\n      command:\n        - api-server\n        - --pki-generate=false\n        - --pki-file=/dockit/pki/combined.pem\n      volumeMounts:\n        - name: pki\n          mountPath: /dockit/pki\n  volumes:\n    - name: pki\n      secret:\n        name: dockit-tls\n        items:\n          - key: tls-combined.pem\n            path: combined.pem\n</code></pre>"},{"location":"guides/cert-manager/#bonus-reloader-by-stakator","title":"Bonus: Reloader by Stakator","text":"<p>You can handle automatic updates and restarts of Dockit by leveraging Reloader</p> <p>If you install reloader and then add the appropriate annotations to the dockit deployment, then when the PKI certificate rotates, reloader will automatically trigger a redeploy of dockit.</p> <pre><code>metadata:\n  annotations:\n    reloader.stakater.com/auto: \"true\"\n</code></pre>"},{"location":"guides/helm/","title":"Installing with Helm","text":"<p>Coming Soon</p>"},{"location":"guides/kustomize/","title":"Installing with Kustomize","text":"<p>Coming Soon</p>"}]}